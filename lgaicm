#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"

die() {
  echo "Error: $*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
lgaicm - AI-powered conventional commit suggestions (multi-line safe)

Usage:
  lgaicm suggest --type <type>
  lgaicm commit  --file <path>

Subcommands:

  suggest
    Generates commit message suggestions from staged changes and prints lines:
      <subject> <===> <path-to-message-file>

    Options:
      -t, --type <type>    Required. One of: feat fix chore docs style refactor perf test ci build

  commit
    Creates the commit using the selected message file (multi-line),
    then cleans up the temp suggestion directory (when safe).

    Options:
      -f, --file <path>    Required. Path returned by the 'suggest' command.

Environment:
  OPENAI_API_KEY                Required.
  LGAICM_MODEL                  Default: gpt-5.1-codex-max
  LGAICM_API_URL                Default: https://api.openai.com/v1/responses
  LGAICM_CURL_TIMEOUT           Default: 45
  LGAICM_MAX_STAT_BYTES         Default: 60000
  LGAICM_MAX_DIFF_BYTES         Default: 200000
  LGAICM_MIN_SUGGESTIONS        Default: 5
  LGAICM_MAX_SUGGESTIONS        Default: 7
  LGAICM_MAX_SUBJECT_LENGTH     Default: 50
EOF
}

require_command() {
  command -v "$1" >/dev/null 2>&1 || die "Required command '$1' is not available in PATH."
}

parse_positive_int() {
  local value="${1:-}"
  local fallback="${2:-}"
  if [[ "$value" =~ ^[0-9]+$ ]] && (( value > 0 )); then
    printf '%s' "$value"
  else
    printf '%s' "$fallback"
  fi
}

truncate_bytes() {
  local text="$1"
  local limit="$2"
  local length
  length="$(LC_ALL=C printf '%s' "$text" | wc -c | awk '{print $1}')"
  if (( length <= limit )); then
    printf '%s' "$text"
  else
    printf '%s' "$text" | head -c "$limit"
    printf '\n\n[Truncated to %s bytes]\n' "$limit"
  fi
}

in_allowed_types() {
  local t="$1"
  case "$t" in
    feat|fix|chore|docs|style|refactor|perf|test|ci|build) return 0 ;;
    *) return 1 ;;
  esac
}

git_require_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not inside a git repository."
}

git_require_staged_changes() {
  if git diff --cached --quiet; then
    die "No staged changes detected. Stage files before generating commit messages."
  fi
}

responses_extract_text() {
  # Reads full JSON API response from stdin and prints best-effort output text.
  # Prefer Responses API convenience field `.output_text`.
  jq -r '
    if (.output_text // empty) != "" then
      .output_text
    else
      try ([.output[].content[] | select(.type=="output_text") | .text] | join("\n")) catch ""
    end
  '
}

normalize_subject() {
  local type="$1"
  local subject="$2"
  local maxlen="$3"

  # Normalize CRLF and trim surrounding whitespace
  subject="$(printf '%s' "$subject" | tr -d '\r' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"

  # Force the requested conventional type
  if [[ "$subject" =~ ^[a-z]+(\([^)]*\))?:[[:space:]] ]]; then
    subject="$(printf '%s' "$subject" | sed -E "s/^[a-z]+(\([^)]*\))?:/${type}\1:/")"
  elif [[ "$subject" =~ ^[a-z]+:[[:space:]] ]]; then
    subject="$(printf '%s' "$subject" | sed -E "s/^[a-z]+:/${type}:/")"
  elif [[ "$subject" =~ ^${type}(\([^)]*\))?:[[:space:]] ]]; then
    : # already ok
  else
    subject="${type}: ${subject}"
  fi

  # Remove trailing period on subject line (conventional style)
  subject="$(printf '%s' "$subject" | sed -E 's/\.[[:space:]]*$//')"

  # Enforce max subject length (byte-based; ok for ASCII conventional commits)
  subject="$(LC_ALL=C printf '%s' "$subject" | head -c "$maxlen")"
  subject="$(printf '%s' "$subject" | sed -E 's/[[:space:]]+$//')"

  printf '%s' "$subject"
}

build_prompt() {
  local type="$1"
  local min="$2"
  local max="$3"
  local max_subject_len="$4"
  local diff_stat="$5"
  local diff_patch="$6"

  # Avoid heredocs here to reduce the chance of CRLF/heredoc delimiter issues.
  printf 'Generate between %s and %s distinct conventional commit message suggestions.\n\n' "$min" "$max"

  printf 'Rules:\n'
  printf -- '- Use the conventional commit type: "%s" (exactly).\n' "$type"
  printf -- '- Subject format: %s(scope): description\n' "$type"
  printf -- '  - scope is optional but preferred when it can be inferred.\n'
  printf -- '  - imperative mood\n'
  printf -- '  - no trailing period\n'
  printf -- '  - max %s characters\n' "$max_subject_len"
  printf -- '- Body:\n'
  printf -- '  - explain what changed and why\n'
  printf -- '  - include notable behavior changes, risks, and tests (if relevant)\n'
  printf -- '  - wrap text at ~72 characters\n'
  printf -- '  - can be multiple paragraphs (plain text)\n\n'

  printf 'Return JSON in this exact shape:\n'
  printf '[\n  { "subject": "…", "body": "…" },\n  ...\n]\n\n'

  printf 'Staged diff summary:\n%s\n\n' "$diff_stat"
  printf 'Full staged diff:\n%s\n' "$diff_patch"
}

suggest_cmd() {
  local TYPE=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -t|--type) TYPE="${2:-}"; shift 2 ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown argument for 'suggest': $1" ;;
    esac
  done

  [[ -n "$TYPE" ]] || die "'suggest' requires --type <type>."
  in_allowed_types "$TYPE" || die "Invalid type '$TYPE'. Allowed: feat fix chore docs style refactor perf test ci build"

  require_command git
  require_command curl
  require_command jq
  require_command mktemp

  [[ -n "${OPENAI_API_KEY:-}" ]] || die "OPENAI_API_KEY environment variable is not set."

  git_require_repo
  git_require_staged_changes

  local MODEL="${LGAICM_MODEL:-gpt-5.1-codex-max}"
  local API_URL="${LGAICM_API_URL:-https://api.openai.com/v1/responses}"
  local CURL_TIMEOUT
  CURL_TIMEOUT="$(parse_positive_int "${LGAICM_CURL_TIMEOUT:-}" 45)"

  local MAX_STAT_BYTES
  MAX_STAT_BYTES="$(parse_positive_int "${LGAICM_MAX_STAT_BYTES:-}" 60000)"
  local MAX_DIFF_BYTES
  MAX_DIFF_BYTES="$(parse_positive_int "${LGAICM_MAX_DIFF_BYTES:-}" 200000)"

  local SUGGESTION_MIN
  SUGGESTION_MIN="$(parse_positive_int "${LGAICM_MIN_SUGGESTIONS:-}" 5)"
  local SUGGESTION_MAX
  SUGGESTION_MAX="$(parse_positive_int "${LGAICM_MAX_SUGGESTIONS:-}" 7)"

  local MAX_SUBJECT_LENGTH
  MAX_SUBJECT_LENGTH="$(parse_positive_int "${LGAICM_MAX_SUBJECT_LENGTH:-}" 50)"

  if (( SUGGESTION_MIN > SUGGESTION_MAX )); then
    SUGGESTION_MIN="$SUGGESTION_MAX"
  fi

  local DIFF_STAT DIFF_PATCH
  DIFF_STAT="$(git diff --cached --stat)"
  DIFF_PATCH="$(git diff --cached)"

  local TRUNC_STAT TRUNC_PATCH
  TRUNC_STAT="$(truncate_bytes "$DIFF_STAT" "$MAX_STAT_BYTES")"
  TRUNC_PATCH="$(truncate_bytes "$DIFF_PATCH" "$MAX_DIFF_BYTES")"

  local SYSTEM_INSTRUCTIONS
  SYSTEM_INSTRUCTIONS=$'You are an expert release engineer.\nReturn ONLY valid JSON. No markdown. No commentary. No surrounding text.\n'

  local PROMPT
  PROMPT="$(
    build_prompt \
      "$TYPE" \
      "$SUGGESTION_MIN" \
      "$SUGGESTION_MAX" \
      "$MAX_SUBJECT_LENGTH" \
      "$TRUNC_STAT" \
      "$TRUNC_PATCH"
  )"

  local REQUEST_PAYLOAD
  REQUEST_PAYLOAD="$(jq -n \
    --arg model "$MODEL" \
    --arg instructions "$SYSTEM_INSTRUCTIONS" \
    --arg input "$PROMPT" \
    '{model: $model, instructions: $instructions, input: $input}')"

  local API_RESPONSE
  if ! API_RESPONSE="$(
    curl -sS \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer ${OPENAI_API_KEY}" \
      --max-time "$CURL_TIMEOUT" \
      "$API_URL" \
      -d "$REQUEST_PAYLOAD"
  )"; then
    die "Failed to call OpenAI API (network/timeout)."
  fi

  # Surface API errors clearly
  if printf '%s' "$API_RESPONSE" | jq -e '.error? != null' >/dev/null 2>&1; then
    local emsg
    emsg="$(printf '%s' "$API_RESPONSE" | jq -r '.error.message // .error // "Unknown API error"')"
    die "OpenAI API error: $emsg"
  fi

  local RAW_OUTPUT
  RAW_OUTPUT="$(printf '%s' "$API_RESPONSE" | responses_extract_text)"

  [[ -n "${RAW_OUTPUT//[[:space:]]/}" ]] || die "AI returned empty output."

  # Must be strict JSON array per system prompt
  if ! printf '%s' "$RAW_OUTPUT" | jq -e 'type=="array"' >/dev/null 2>&1; then
    echo "AI output was not valid JSON array. Raw output:" >&2
    printf '%s\n' "$RAW_OUTPUT" >&2
    exit 1
  fi

  local count
  count="$(printf '%s' "$RAW_OUTPUT" | jq 'length')"
  (( count > 0 )) || die "AI returned zero suggestions."

  # Create a session dir to store multi-line messages (real newlines).
  local SESSION_DIR
  SESSION_DIR="$(mktemp -d "${TMPDIR:-/tmp}/lgaicm.XXXXXX")"
  touch "$SESSION_DIR/.lgaicm_session"

  # Write each suggestion to its own file and print a single-line mapping for LazyGit.
  local i
  for (( i=0; i<count; i++ )); do
    local subject body file
    subject="$(printf '%s' "$RAW_OUTPUT" | jq -r ".[$i].subject // empty")"
    body="$(printf '%s' "$RAW_OUTPUT" | jq -r ".[$i].body // empty")"

    subject="$(normalize_subject "$TYPE" "$subject" "$MAX_SUBJECT_LENGTH")"
    body="$(printf '%s' "$body" | tr -d '\r' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"

    [[ -n "${subject//[[:space:]]/}" ]] || continue

    file="$SESSION_DIR/msg-$(printf '%03d' "$((i+1))").txt"

    {
      printf '%s\n' "$subject"
      printf '\n'
      if [[ -n "${body//[[:space:]]/}" ]]; then
        printf '%s\n' "$body"
      fi
    } >"$file"

    # Output format consumed by LazyGit menuFromCommand:
    # label is subject; value is file path
    printf '%s <===> %s\n' "$subject" "$file"
  done
}

commit_cmd() {
  local FILE=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--file) FILE="${2:-}"; shift 2 ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown argument for 'commit': $1" ;;
    esac
  done

  [[ -n "$FILE" ]] || die "'commit' requires --file <path>."
  [[ -f "$FILE" ]] || die "Commit message file does not exist: $FILE"

  require_command git
  git_require_repo

  # Create commit using the multi-line message file (subject + blank line + body)
  # This is equivalent to: git commit -m "<subject>" -m "<body>"
  git commit -F "$FILE"

  # Cleanup: only delete directories we created (marker file present)
  local dir
  dir="$(cd "$(dirname "$FILE")" && pwd -P)"
  if [[ -f "$dir/.lgaicm_session" ]]; then
    rm -rf "$dir"
  fi
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  case "$1" in
    suggest) shift; suggest_cmd "$@" ;;
    commit)  shift; commit_cmd "$@" ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown subcommand: $1 (use --help)" ;;
  esac
}

main "$@"
