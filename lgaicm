#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
DEBUG_LOG="${LGAICM_DEBUG_LOG:-/tmp/lgaicm_debug.log}"

die() {
  echo "Error: $*" >&2
  exit 1
}

log_debug() {
  local timestamp
  timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
  printf '[%s] %s\n' "$timestamp" "$*" >> "$DEBUG_LOG"
}

log_debug_multiline() {
  local label="$1"
  local content="$2"
  local timestamp
  timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
  {
    printf '\n========================================\n'
    printf '[%s] %s\n' "$timestamp" "$label"
    printf '========================================\n'
    printf '%s\n' "$content"
    printf '========================================\n\n'
  } >> "$DEBUG_LOG"
}

usage() {
  cat <<'EOF'
lgaicm - AI-powered conventional commit suggestions (multi-line safe)

Usage:
  lgaicm suggest --type <type>
  lgaicm commit  --file <path>

Subcommands:

  suggest
    Generates commit message suggestions from staged changes and prints lines:
      <subject> <===> <path-to-message-file>

    Options:
      -t, --type <type>    Required. One of: feat fix chore docs style refactor perf test ci build

  commit
    Creates the commit using the selected message file (multi-line),
    then cleans up the temp suggestion directory (when safe).

    Options:
      -f, --file <path>    Required. Path returned by the 'suggest' command.

Environment:
  GOOGLEAI_API_KEY                Required.
  LGAICM_MODEL                  Default: gemini-3-flash-preview
  LGAICM_API_URL                Default: https://generativelanguage.googleapis.com/v1beta/interactions
  LGAICM_CURL_TIMEOUT           Default: 45
  LGAICM_MAX_STAT_BYTES         Default: 60000
  LGAICM_MAX_DIFF_BYTES         Default: 200000
  LGAICM_MIN_SUGGESTIONS        Default: 5
  LGAICM_MAX_SUGGESTIONS        Default: 7
  LGAICM_MAX_SUBJECT_LENGTH     Default: 500
  LGAICM_DEBUG_LOG              Default: /tmp/lgaicm_debug.log
EOF
}

require_command() {
  command -v "$1" >/dev/null 2>&1 || die "Required command '$1' is not available in PATH."
}

parse_positive_int() {
  local value="${1:-}"
  local fallback="${2:-}"
  if [[ "$value" =~ ^[0-9]+$ ]] && (( value > 0 )); then
    printf '%s' "$value"
  else
    printf '%s' "$fallback"
  fi
}

truncate_bytes() {
  local text="$1"
  local limit="$2"
  local length
  length="$(LC_ALL=C printf '%s' "$text" | wc -c | awk '{print $1}')"
  if (( length <= limit )); then
    printf '%s' "$text"
  else
    printf '%s' "$text" | head -c "$limit"
    printf '\n\n[Truncated to %s bytes]\n' "$limit"
  fi
}

in_allowed_types() {
  local t="$1"
  case "$t" in
    feat|fix|chore|docs|style|refactor|perf|test|ci|build) return 0 ;;
    *) return 1 ;;
  esac
}

git_require_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not inside a git repository."
}

git_require_staged_changes() {
  if git diff --cached --quiet; then
    die "No staged changes detected. Stage files before generating commit messages."
  fi
}

responses_extract_text() {
  # Gemini Interaction API returns an 'outputs' array.
  # We filter for items where type is "text" and join them.
  jq -r '
    [.outputs[]? | select(.type == "text") | .text]
    | if length > 0 then join("") else empty end
  '
}

normalize_subject() {
  local type="$1"
  local subject="$2"
  local maxlen="$3"

  subject="$(printf '%s' "$subject" | tr -d '\r' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"

  local prefix_pattern="^[a-z]+(\([^)]*\))?:[[:space:]]"
  local simple_pattern="^[a-z]+:[[:space:]]"

  if [[ "$subject" =~ $prefix_pattern ]]; then
    subject="$(printf '%s' "$subject" | sed -E "s/^[a-z]+(\([^)]*\))?:/${type}\1:/")"
  elif [[ "$subject" =~ $simple_pattern ]]; then
    subject="$(printf '%s' "$subject" | sed -E "s/^[a-z]+:/${type}:/")"
  else
    subject="${type}: ${subject}"
  fi

  subject="$(printf '%s' "$subject" | sed -E 's/\.[[:space:]]*$//')"

  subject="$(LC_ALL=C printf '%s' "$subject" | head -c "$maxlen")"
  subject="$(printf '%s' "$subject" | sed -E 's/[[:space:]]+$//')"

  printf '%s' "$subject"
}

build_prompt() {
  local type="$1"
  local min="$2"
  local max="$3"
  local max_subject_len="$4"
  local diff_stat="$5"
  local diff_patch="$6"

  printf 'Generate between %s and %s distinct conventional commit message suggestions.\n\n' "$min" "$max"

  printf 'Rules:\n'
  printf -- '- Use the conventional commit type: "%s" (exactly).\n' "$type"
  printf -- '- Subject format: %s(scope): description\n' "$type"
  printf -- '  - scope is optional but preferred when it can be inferred.\n'
  printf -- '  - imperative mood\n'
  printf -- '  - no trailing period\n'
  printf -- '  - max %s characters\n' "$max_subject_len"
  printf -- '- Body:\n'
  printf -- '  - explain what changed and why\n'
  printf -- '  - if multiple change topics or multiple scope changes, tell about all of them (do not try to pick one)\n'
  printf -- '  - include notable behavior changes\n'
  printf -- '  - include notable risks\n'
  printf -- '  - include things to test to avoid regression\n'
  printf -- '  - wrap text at ~72 characters\n'
  printf -- '  - include code snippets if needed, but indent 4 spaces to make the difference from simple text\n'
  printf -- '  - can be multiple paragraphs, be verbose (plain text)\n\n'

  printf 'Return JSON in this exact shape:\n'
  printf '[\n  { "subject": "…", "body": "…" },\n  ...\n]\n\n'

  printf 'Staged diff summary:\n%s\n\n' "$diff_stat"
  printf 'Full staged diff:\n%s\n' "$diff_patch"
}

suggest_cmd() {
  local TYPE=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -t|--type) TYPE="${2:-}"; shift 2 ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown argument for 'suggest': $1" ;;
    esac
  done

  log_debug "=== Starting suggest command ==="
  log_debug "Type: $TYPE"

  [[ -n "$TYPE" ]] || die "'suggest' requires --type <type>."
  in_allowed_types "$TYPE" || die "Invalid type '$TYPE'. Allowed: feat fix chore docs style refactor perf test ci build"

  require_command git
  require_command curl
  require_command jq
  require_command mktemp

  [[ -n "${GOOGLEAI_API_KEY:-}" ]] || die "GOOGLEAI_API_KEY environment variable is not set."

  git_require_repo
  git_require_staged_changes

  local MODEL="${LGAICM_MODEL:-gemini-3-flash-preview}"
  local API_URL="${LGAICM_API_URL:-https://generativelanguage.googleapis.com/v1beta/interactions}"
  local CURL_TIMEOUT
  CURL_TIMEOUT="$(parse_positive_int "${LGAICM_CURL_TIMEOUT:-}" 240)"

  log_debug "Model: $MODEL"
  log_debug "API URL: $API_URL"
  log_debug "Timeout: $CURL_TIMEOUT"

  local MAX_STAT_BYTES
  MAX_STAT_BYTES="$(parse_positive_int "${LGAICM_MAX_STAT_BYTES:-}" 60000)"
  local MAX_DIFF_BYTES
  MAX_DIFF_BYTES="$(parse_positive_int "${LGAICM_MAX_DIFF_BYTES:-}" 200000)"

  local SUGGESTION_MIN
  SUGGESTION_MIN="$(parse_positive_int "${LGAICM_MIN_SUGGESTIONS:-}" 5)"
  local SUGGESTION_MAX
  SUGGESTION_MAX="$(parse_positive_int "${LGAICM_MAX_SUGGESTIONS:-}" 7)"

  local MAX_SUBJECT_LENGTH
  MAX_SUBJECT_LENGTH="$(parse_positive_int "${LGAICM_MAX_SUBJECT_LENGTH:-}" 500)"

  if (( SUGGESTION_MIN > SUGGESTION_MAX )); then
    SUGGESTION_MIN="$SUGGESTION_MAX"
  fi

  local DIFF_STAT DIFF_PATCH
  DIFF_STAT="$(git diff --cached --stat)"
  DIFF_PATCH="$(git diff --cached)"

  log_debug "Diff stat length: $(printf '%s' "$DIFF_STAT" | wc -c | awk '{print $1}') bytes"
  log_debug "Diff patch length: $(printf '%s' "$DIFF_PATCH" | wc -c | awk '{print $1}') bytes"

  local TRUNC_STAT TRUNC_PATCH
  TRUNC_STAT="$(truncate_bytes "$DIFF_STAT" "$MAX_STAT_BYTES")"
  TRUNC_PATCH="$(truncate_bytes "$DIFF_PATCH" "$MAX_DIFF_BYTES")"

  local SYSTEM_INSTRUCTIONS
  SYSTEM_INSTRUCTIONS=$'You are an expert release engineer.\nReturn ONLY valid JSON. No markdown. No commentary. No surrounding text.\n'

  local PROMPT
  PROMPT="$(
    build_prompt \
      "$TYPE" \
      "$SUGGESTION_MIN" \
      "$SUGGESTION_MAX" \
      "$MAX_SUBJECT_LENGTH" \
      "$TRUNC_STAT" \
      "$TRUNC_PATCH"
  )"

  log_debug_multiline "SYSTEM INSTRUCTIONS" "$SYSTEM_INSTRUCTIONS"
  log_debug_multiline "USER PROMPT" "$PROMPT"

  # Construct Gemini Interaction API Payload
  local REQUEST_PAYLOAD
  REQUEST_PAYLOAD="$(jq -n \
    --arg model "$MODEL" \
    --arg instructions "$SYSTEM_INSTRUCTIONS" \
    --arg input "$PROMPT" \
    '{
       model: $model,
       system_instruction: $instructions,
       input: [
         {
           role: "user",
           content: $input
         }
       ]
    }')"

  log_debug_multiline "REQUEST PAYLOAD (JSON)" "$REQUEST_PAYLOAD"

  local API_RESPONSE
  if ! API_RESPONSE="$(
    curl -sS \
      -X POST \
      -H "Content-Type: application/json" \
      -H "x-goog-api-key: ${GOOGLEAI_API_KEY}" \
      --max-time "$CURL_TIMEOUT" \
      "$API_URL" \
      -d "$REQUEST_PAYLOAD"
  )"; then
    log_debug "CURL FAILED"
    die "Failed to call Gemini API (network/timeout)."
  fi

  log_debug_multiline "API RESPONSE (RAW)" "$API_RESPONSE"

  # Check for API-level errors
  # Google APIs typically return { "error": { "code": ..., "message": ... } }
  if printf '%s' "$API_RESPONSE" | jq -e '.error != null' >/dev/null 2>&1; then
    local emsg
    emsg="$(printf '%s' "$API_RESPONSE" | jq -r '.error.message // .error // "Unknown API error"')"
    log_debug "API ERROR: $emsg"
    die "Gemini API error: $emsg"
  fi

  # Check response status if available (Gemini Interaction API includes "status": "completed")
  local response_status
  response_status="$(printf '%s' "$API_RESPONSE" | jq -r '.status // "unknown"')"
  log_debug "Response status: $response_status"

  if [[ "$response_status" != "completed" && "$response_status" != "unknown" ]]; then
    log_debug "Response not completed. Status: $response_status"
    die "API response not completed. Status: $response_status"
  fi

  local RAW_OUTPUT
  RAW_OUTPUT="$(printf '%s' "$API_RESPONSE" | responses_extract_text)"

  log_debug_multiline "EXTRACTED OUTPUT" "$RAW_OUTPUT"

  if [[ -z "${RAW_OUTPUT//[[:space:]]/}" ]]; then
    # Provide more diagnostic info
    local output_types
    output_types="$(printf '%s' "$API_RESPONSE" | jq -r '[.outputs[]?.type] | join(", ")')"
    log_debug "Output types found: $output_types"
    die "AI returned empty text output. Output types in response: $output_types"
  fi

  # Clean up markdown code blocks if the AI wrapped the JSON
  # Sometimes models wrap JSON in ```json ... ``` despite instructions
  if [[ "$RAW_OUTPUT" =~ ^[[:space:]]*\`\`\` ]]; then
      log_debug "Detected markdown code block, stripping..."
      RAW_OUTPUT="$(printf '%s' "$RAW_OUTPUT" | sed -E 's/^[[:space:]]*```[a-zA-Z]*//; s/```[[:space:]]*$//')"
  fi

  if ! printf '%s' "$RAW_OUTPUT" | jq -e 'type=="array"' >/dev/null 2>&1; then
    log_debug "OUTPUT IS NOT A VALID JSON ARRAY"
    echo "AI output was not valid JSON array. Raw output:" >&2
    printf '%s\n' "$RAW_OUTPUT" >&2
    exit 1
  fi

  local count
  count="$(printf '%s' "$RAW_OUTPUT" | jq 'length')"
  log_debug "Number of suggestions: $count"
  (( count > 0 )) || die "AI returned zero suggestions."

  local SESSION_DIR
  SESSION_DIR="$(mktemp -d "${TMPDIR:-/tmp}/lgaicm.XXXXXX")"
  touch "$SESSION_DIR/.lgaicm_session"
  log_debug "Session directory: $SESSION_DIR"

  local i
  for (( i=0; i<count; i++ )); do
    local subject body file
    subject="$(printf '%s' "$RAW_OUTPUT" | jq -r ".[$i].subject // empty")"
    body="$(printf '%s' "$RAW_OUTPUT" | jq -r ".[$i].body // empty")"

    log_debug "Processing suggestion $((i+1)): subject='$subject'"

    subject="$(normalize_subject "$TYPE" "$subject" "$MAX_SUBJECT_LENGTH")"
    body="$(printf '%s' "$body" | tr -d '\r' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"

    [[ -n "${subject//[[:space:]]/}" ]] || continue

    file="$SESSION_DIR/msg-$(printf '%03d' "$((i+1))").txt"

    {
      printf '%s\n' "$subject"
      printf '\n'
      if [[ -n "${body//[[:space:]]/}" ]]; then
        printf '%s\n' "$body"
      fi
    } >"$file"

    log_debug "Created file: $file"
    printf '%s <===> %s\n' "$subject" "$file"
  done

  log_debug "=== Suggest command completed ==="
}

commit_cmd() {
  local FILE=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--file) FILE="${2:-}"; shift 2 ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown argument for 'commit': $1" ;;
    esac
  done

  log_debug "=== Starting commit command ==="
  log_debug "File: $FILE"

  [[ -n "$FILE" ]] || die "'commit' requires --file <path>."
  [[ -f "$FILE" ]] || die "Commit message file does not exist: $FILE"

  require_command git
  git_require_repo

  log_debug_multiline "COMMIT MESSAGE CONTENT" "$(cat "$FILE")"

  git commit -F "$FILE"

  local dir
  dir="$(cd "$(dirname "$FILE")" && pwd -P)"
  if [[ -f "$dir/.lgaicm_session" ]]; then
    log_debug "Cleaning up session directory: $dir"
    rm -rf "$dir"
  fi

  log_debug "=== Commit command completed ==="
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  case "$1" in
    suggest) shift; suggest_cmd "$@" ;;
    commit)  shift; commit_cmd "$@" ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown subcommand: $1 (use --help)" ;;
  esac
}

main "$@"

